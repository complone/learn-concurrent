大家好，我是来自微医集团交易研发组的风轮，目前负责基于netty的c/s消息收发sdk研发工作

假若有同学选择java这门语言，最重要的是基础并非工作中用到的框架，而是来自于JDK底层的设计思想。每周有空会开启直播，希望借此机会沉淀自己的技术功底，也祝愿听完分享的朋友们有更多售货。最重要的一点是欢迎大家指出我分享过程中的不足，共同学习。

2019.10.23


- 第一章 可见性，原子性和有序性问题。并发编程bug的源头 

进入互联网时代后，计算机的CPU,内存，I/O设备都在不断迭代，不断朝着更快的方向发展。

核心矛盾：CPU，I/O设备，内存的速度差异
example:CPU执行一条普通指令如果需要一天，那么CPU读写内存得等待一年的时间

>java访问内存的方法

每种语言的最底层都是通过汇编语言访问内存，java也不例外，如果有研读过JDK源码的人会发现，一些线程的等待，阻塞方法在底层都是被声明为native方法

因此使用了native的程序可移植性都不太高。另外native方法在JVM中运行时数据区也和其它方法不一样，它有专门的本地方法栈。
主要用于加载文件和动态链接库，由于Java语言无法访问操作系统底层信息（比如：底层硬件设备等），这时候就需要借助C语言来完成了。被native修饰的方法可以被C语言重写。

>native方法指定的步骤

Java程序中声明native修饰的方法，类似于abstract修饰的方法，只有方法签名，没有方法实现。

- 编译该java文件，会产生一个.class文件。
- 使用javah编译上一步产生的class文件，会产生一个.h文件。
- 写一个.cpp文件实现上一步中.h文件中的方法。
- 将上一步的.cpp文件编译成动态链接库文件.dll。
- 使用System或是Runtime中的loadLibrary()方法加载上一步的产生的动态连接库文件了。

>基于OS对CPU高性能优化做出的改变

- CPU增加了缓存,用来均衡与内存速度差异
- 操作系统增加了进程，线程，以分时复用CPU;进而均衡CPU与I/O设备的速度差异
- 编译器程序优化指令执行次序，使缓存更合理被利用

>源头之一：缓存导致的可见性问题
在单核时代，所有的线程都是在一个CPU上执行，CPU缓存与内存的数据一致性容易解决。
因为所有的线程都是操作同一个CPU的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。
线程A和线程B都是操作同一个CPU里面的缓存，所以线程A更新了变量V的值，那么线程B之后再访问变量V，得到的值一定是V的最新值


